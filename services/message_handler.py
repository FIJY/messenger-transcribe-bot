# services/message_handler.py - –ü–û–õ–ù–ê–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
import logging
import requests
import os
from typing import Dict, Any, Optional, List
from .media_handler import MediaHandler
from .database import Database
from .translation_service import TranslationService
from .audio_processor import AudioProcessor  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –æ—á–∏—Å—Ç–∫–∏

logger = logging.getLogger(__name__)


class MessageHandler:
    def __init__(self, media_handler: MediaHandler, database: Database, translation_service: TranslationService):
        self.media_handler = media_handler
        self.database = database
        self.translation_service = translation_service
        self.audio_processor = AudioProcessor()  # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
        self.page_access_token = os.getenv('PAGE_ACCESS_TOKEN')
        self.FREE_DAILY_LIMIT = int(os.getenv('FREE_DAILY_LIMIT', '10'))
        self.PREMIUM_DAILY_LIMIT = int(os.getenv('PREMIUM_DAILY_LIMIT', '1000'))

    def handle_message(self, webhook_event: Dict[str, Any]):
        """–ì–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–±—ã—Ç–∏–π –æ—Ç Messenger."""
        sender_id = webhook_event.get('sender', {}).get('id')
        if not sender_id:
            return

        user = self.database.get_user(sender_id)
        if not user:
            user = self.database.create_user(sender_id)
            self._send_welcome_message(sender_id)
            return

        if 'message' in webhook_event:
            message = webhook_event['message']

            if 'quick_reply' in message:
                payload = message['quick_reply'].get('payload')
                if payload:
                    self._handle_quick_reply(sender_id, payload, user)  # –ü–µ—Ä–µ–¥–∞–µ–º user
                    return

            if not self._check_usage_limits(user) and 'attachments' in message:
                self._send_limit_exceeded_message(sender_id)
                return

            if 'attachments' in message:
                self._handle_attachments(sender_id, message['attachments'], user)
                return

            if 'text' in message:
                self._handle_text_message(sender_id, message['text'])
                return

        self._send_text_message(sender_id, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ –∏–ª–∏ –≤–∏–¥–µ–æ —Ñ–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏.")

    def _handle_quick_reply(self, sender_id: str, payload: str, user: Dict[str, Any]):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –±—ã—Å—Ç—Ä—ã–µ –æ—Ç–≤–µ—Ç—ã, –≤–∫–ª—é—á–∞—è –±–µ—Å—à–æ–≤–Ω—ã–π —Ä–µ—Ç—Ä–∞–π."""
        logger.info(f"User {sender_id} clicked quick reply: {payload}")

        if payload.startswith('RETRY_LANG_'):
            # üîß –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ë–ï–°–®–û–í–ù–´–ô –†–ï–¢–†–ê–ô
            retry_info = self.database.get_retry_info(sender_id)
            if not retry_info or not retry_info.get('file_path'):
                self._send_text_message(sender_id,
                                        "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ñ–∞–π–ª –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ —Å–Ω–æ–≤–∞.")
                return

            file_to_retry = retry_info['file_path']
            if not os.path.exists(file_to_retry):
                self._send_text_message(sender_id,
                                        f"‚ùå –ò—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª —É–∂–µ —É–¥–∞–ª–µ–Ω ({file_to_retry}). –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ —Å–Ω–æ–≤–∞.")
                return

            lang_code = payload.replace('RETRY_LANG_', '').lower()
            lang_names = {'km': '–ö—Ö–º–µ—Ä—Å–∫–∏–π', 'th': '–¢–∞–π—Å–∫–∏–π', 'vi': '–í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π', 'en': '–ê–Ω–≥–ª–∏–π—Å–∫–∏–π'}
            lang_name = lang_names.get(lang_code, lang_code.upper())

            self._send_text_message(sender_id, f"‚úÖ –ü–æ–Ω—è–ª! –ü–æ–≤—Ç–æ—Ä–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª —Å —è–∑—ã–∫–æ–º: **{lang_name}**...")

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —è–∑—ã–∫ –¥–ª—è —Ä–µ—Ç—Ä–∞—è
            user['preferred_language'] = lang_code

            # –ü–æ–≤—Ç–æ—Ä–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¢–û–¢ –ñ–ï –°–ê–ú–´–ô —Ñ–∞–π–ª
            result = self.media_handler.process_media(file_to_retry, user)

            if result.get('success'):
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π, –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                new_response = self._format_transcription_response(result)
                self._send_text_message(sender_id, new_response)
            else:
                self._send_text_message(sender_id, f"‚ùå –ü—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {result.get('error')}")

            # –û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ —Ä–µ—Ç—Ä–∞—è
            self.audio_processor.cleanup_temp_file(file_to_retry)
            self.database.store_retry_info(sender_id, {'file_path': None})  # –û—á–∏—â–∞–µ–º –∏–Ω—Ñ–æ
            return

        if payload == 'LANG_CORRECT':
            retry_info = self.database.get_retry_info(sender_id)
            if retry_info and retry_info.get('file_path'):
                self.audio_processor.cleanup_temp_file(retry_info['file_path'])
                self.database.store_retry_info(sender_id, {'file_path': None})
            self._send_text_message(sender_id, "üëç –û—Ç–ª–∏—á–Ω–æ! –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.")
            return

    def _handle_attachments(self, sender_id: str, attachments: List[Dict], user: Dict[str, Any]):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–ª–æ–∂–µ–Ω–∏—è (–∞—É–¥–∏–æ/–≤–∏–¥–µ–æ —Ñ–∞–π–ª—ã)."""
        # –°–±—Ä–æ—Å —è–∑—ã–∫–∞ –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
        if user.get('preferred_language'):
            self.database.set_user_language_preference(sender_id, None)
            user = self.database.get_user(sender_id)

        for attachment in attachments:
            if attachment.get('type') in ['audio', 'video']:
                # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª –∏ –ø–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ –Ω–µ–º—É
                original_file_path = self._download_file(attachment)
                if not original_file_path:
                    self._send_text_message(sender_id, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª.")
                    return

                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª
                self._process_media_file(sender_id, original_file_path, user)
                return
        self._send_text_message(sender_id, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π –∞—É–¥–∏–æ –∏–ª–∏ –≤–∏–¥–µ–æ —Ñ–∞–π–ª.")

    def _download_file(self, attachment: Dict) -> Optional[str]:
        """–°–∫–∞—á–∏–≤–∞–µ—Ç —Ñ–∞–π–ª –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ –Ω–µ–º—É."""
        try:
            file_url = attachment.get('payload', {}).get('url')
            if not file_url: return None

            headers = {'Authorization': f'Bearer {self.page_access_token}'}
            response = requests.get(file_url, headers=headers, stream=True, timeout=60)
            response.raise_for_status()

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            with self.audio_processor.audio_processor.tempfile.NamedTemporaryFile(delete=False,
                                                                                  suffix='.tmp') as temp_file:
                temp_file_path = temp_file.name
                for chunk in response.iter_content(chunk_size=8192):
                    temp_file.write(chunk)
            return temp_file_path
        except requests.RequestException as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
            return None

    def _process_media_file(self, sender_id: str, file_path: str, user: Dict[str, Any]):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ª–æ–∫–∞–ª—å–Ω—ã–π –º–µ–¥–∏–∞ —Ñ–∞–π–ª."""
        try:
            self._send_processing_message(sender_id)

            is_valid, error_msg = self.media_handler.validate_file(file_path, user.get('is_premium', False))
            if not is_valid:
                self._send_text_message(sender_id, f"‚ùå {error_msg}")
                self.audio_processor.cleanup_temp_file(file_path)  # –û—á–∏—â–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ñ–∞–π–ª
                return

            result = self.media_handler.process_media(file_path, user)
            processed_audio_path = result.get('processed_audio_path')

            if not result.get('success'):
                self._send_text_message(sender_id, f"‚ùå {result.get('error', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}")
                self.audio_processor.cleanup_temp_file(processed_audio_path)  # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
                return

            self.database.save_transcription(user_id=sender_id, **result)
            self.database.increment_usage(user_id=sender_id)

            self._send_transcription_with_language_buttons(sender_id, result)
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {e}", exc_info=True)
            self._send_text_message(sender_id, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")
            if 'file_path' in locals() and file_path:
                self.audio_processor.cleanup_temp_file(file_path)

    def _send_transcription_with_language_buttons(self, sender_id: str, result: Dict[str, Any]):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é –∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ, –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è —è–∑—ã–∫–∞."""
        response_text = self._format_transcription_response(result)
        processed_audio_path = result.get('processed_audio_path')

        if self._should_show_language_correction_buttons(result) and processed_audio_path:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ —Ä–µ—Ç—Ä–∞—è
            self.database.store_retry_info(sender_id, {'file_path': processed_audio_path})

            question = "\n\nü§î –Ø–∑—ã–∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ? –ï—Å–ª–∏ –Ω–µ—Ç, –≤—ã–±–µ—Ä–∏—Ç–µ –≤–µ—Ä–Ω—ã–π:"
            quick_replies = [
                {"content_type": "text", "title": "‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ", "payload": "LANG_CORRECT"},
                {"content_type": "text", "title": "üá∞üá≠ –ö—Ö–º–µ—Ä—Å–∫–∏–π", "payload": "RETRY_LANG_KM"},
                {"content_type": "text", "title": "üáπüá≠ –¢–∞–π—Å–∫–∏–π", "payload": "RETRY_LANG_TH"},
                {"content_type": "text", "title": "üáªüá≥ –í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π", "payload": "RETRY_LANG_VI"},
            ]
            self._send_text_message(sender_id, response_text)
            self._send_message_with_quick_replies(sender_id, question, quick_replies)
        else:
            self._send_text_message(sender_id, response_text)
            # –ï—Å–ª–∏ –∫–Ω–æ–ø–∫–∏ –Ω–µ –Ω—É–∂–Ω—ã, —Ñ–∞–π–ª –º–æ–∂–Ω–æ —É–¥–∞–ª—è—Ç—å
            if processed_audio_path:
                self.audio_processor.cleanup_temp_file(processed_audio_path)

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def _handle_text_message(self, sender_id: str, text: str):
        pass

    def _check_usage_limits(self, user: Dict[str, Any]) -> bool:
        pass

    def _send_welcome_message(self, sender_id: str):
        pass

    def _send_limit_exceeded_message(self, sender_id: str):
        pass

    def _send_processing_message(self, sender_id: str):
        pass

    def _should_show_language_correction_buttons(self, result: Dict[str, Any]) -> bool:
        pass

    def _format_transcription_response(self, result: Dict[str, Any]) -> str:
        pass

    def _send_text_message(self, recipient_id: str, message_text: str):
        pass

    def _send_message_with_quick_replies(self, recipient_id: str, text: str, quick_replies: List[Dict]):
        pass

    def _send_api_request(self, recipient_id: str, message_data: Dict):
        pass